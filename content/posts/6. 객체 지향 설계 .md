---
title: 6. 객체 지향 설계
date: 2025-10-06
draft: false
tags: []
cover:
  image: ""
  alt:
  caption:
---

# 6. 객체 지향 설계 

---

## 01 객체 지향 분석과 모델링 개념

객체 지향 분석은 **현실 세계의 문제 영역에서 객체의 집합을 발견하고, 객체들 간의 상호 작용을 파악하는 반복적인 과정**입니다. 이 분석 과정은 객체 지향적 관점에서 문제 영역의 객체 지향 모델을 개발하는 것을 목표로 합니다.

**모델링**은 시스템의 기능이나 동적 행동과 같은 특징을 분석하기 위해 **간소화하거나 시스템의 특징을 수학적으로 표현하는 과정**을 의미합니다. 모델링의 목적은 다음과 같습니다:

1. **시스템 특징 표현:** 시스템의 특징을 명확하게 이해하고, 다른 사람에게 시스템의 표현을 가능하게 합니다.
2. **설계 및 구현 도움:** 모델링은 시스템의 품질과 개발 생산성을 파악하고 높이는 데 도움을 주며, 설계, 구현, 테스트, 운영, 유지보수 등 후속 개발 단계에 필요한 시스템의 청사진과 지침을 제공합니다.

객체 지향 분석 단계에서는 객체, 속성(attribute), 메서드, 관계(association, aggregation), 일반화/특수화 등을 식별함으로써, 분석, 설계, 구현 산출물의 재사용을 극대화하여 소프트웨어 개발 생산성을 높이는 것을 목표로 합니다. 이러한 객체 지향 방법론은 분석, 설계, 구현의 단계를 거치는 소프트웨어 개발 방법론 중 하나입니다.

### 모델링의 세 가지 관점

소프트웨어를 바라보는 관점에 따라 모델링을 세 가지 관점으로 나누어 표현할 수 있습니다:

1. **기능 관점(Functioning Viewpoint)**
    - **내용:** 소프트웨어가 시스템에 제공해야 할 **필요한 기능을 설명**하는 관점입니다.
    - **초점:** 기능, 제약 사항, 연산 및 예상 결과에 중점을 둡니다.
    - **활용:** 이 관점의 모델은 사용자 및 시스템의 상호 작용을 나타내는 **유스케이스(Use Case)** 를 활용하여 표현됩니다. 유스케이스는 고객이 요구하는 사항을 객관적이고 적극적으로 확인하고 분석하며, 시스템 개발을 효율적으로 진행하는 데 도움을 줍니다.
2. **동적 관점(Dynamic Viewpoint)**
    - **내용:** 시간이 지남에 따라 **시스템의 상태(state) 변화 및 동작(behavior)에 초점을 맞춘** 모델입니다.
    - **초점:** 시간의 흐름, 이벤트, 메시지 흐름 등을 강조합니다.
3. **정보 관점(Information Viewpoint)**
    - **내용:** 시스템 내부에 존재하는 **정보 객체들과 그들 간의 구조적 관계**를 나타내는 모델입니다.
    - **초점:** 시스템에 필요한 정보 객체, 이들의 속성, 그리고 객체들 사이의 관계 규명에 중점을 둡니다.


---

## 02 객체 지향 설계와 원리

객체 지향 설계는 객체 지향 분석 과정에서 발견된 추상적인 객체 지향 모델을 바탕으로, **실제 소프트웨어 구현의 물리적인 모습**을 어떻게 가져가야 할지 구체적으로 정의하는 단계입니다. 이 과정은 유스케이스 시나리오와 UML 클래스 다이어그램 등을 통해 도출된 클래스와 그 관계를 기반으로 진행됩니다.

이 섹션에서 다루는 주요 객체 지향 설계 원리는 다음과 같습니다:

### 가) 객체와 클래스 (Object and Class)

소프트웨어 시스템을 설계하는 데 사용되는 소프트웨어 구성 요소를 **객체**라고 합니다. 객체는 속성(Attribute)과 메서드(Operation/행위)를 가지고 있어야 합니다.

- **클래스(Class)** 는 객체와 유사한 속성 및 행위를 가질 때, 이들을 정의하는 **틀(Template)** 또는 **청사진(Blueprint)** 을 의미합니다. 즉, 클래스는 비슷한 객체들을 그룹화할 수 있게 해줍니다.

### 나) 캡슐화 (Encapsulation)

캡슐화는 **객체의 속성(데이터)과 메서드(오퍼레이션)** 를 하나로 묶어 보호하는 기법을 의미합니다.

- **목적 및 특징:**
    - 모듈의 내부 상세 구현 내용을 숨기고 외부에 대한 의존도를 최소화하는 것이 주된 목적입니다.
    - 캡슐화는 모듈의 유지보수성과 재사용성을 높이는 데 기여합니다.
    - 객체 지향 언어들은 보통 캡슐화를 지원하는 기능을 제공합니다.

### 다) 상속 (Inheritance)

상속은 **클래스 간에 유사성이 존재할 때** 이미 정의된 상위 클래스(Superclass)의 속성 및 오퍼레이션을 하위 클래스(Subclass)가 재사용할 수 있도록 하는 메커니즘입니다.

- **장점:** 상속을 통해 새로운 클래스의 정의가 간소화되고, 소프트웨어의 재사용성이 향상되며, 프로그램의 가독성과 수정 편의성이 높아집니다.
- **분류:** 클래스 간의 관계는 공통적인 속성 및 행위를 상위 클래스에 정의하는 **일반화(Generalization)** 와 상위 클래스를 물려받아 새로운 클래스를 정의하는 **특수화(Specialization)** 로 나타납니다. 일반화는 인터페이스(Interface)를 통해서도 구현할 수 있습니다.

### 라) 다형성 (Polymorphism)

다형성은 **객체의 특징에 따라 다르게 동작**하거나 **하나의 오퍼레이터(연산자)가 다양한 방식으로 사용**될 수 있는 능력을 의미합니다.

- **구현 방법:**
    - 다형성은 보통 메서드 오버로딩(Overloading, 정의적 다형성)과 오버라이딩(Overriding, 하위 클래스에서 재정의)을 통해 구현되는데, 오버로딩은 컴파일 시점에, 오버라이딩은 실행 시점(Run-time Binding)에 동작이 정해집니다.
    - 다형성은 객체 간의 관계를 간결하게 표현하여 시스템 개발을 효과적이고 효율적으로 만드는 데 기여합니다.


--- 
## 03 정적 모델링과 동적 모델링 
### 1. 정적 모델링 (Static Modeling)

정적 모델링은 **시간의 개념이 개입되지 않은** 객체의 정적인 측면을 모델링하는 것을 의미합니다.

**가) 정의 및 대상** 정적 모델링은 시스템을 구성하는 **클래스, 속성, 관계 등 정적인 측면**을 모델링합니다. 이는 일반적으로 시스템에 존재하는 데이터나 정보에 초점을 맞추며, 관계형 데이터베이스 시스템의 관계 모델링(Relationship Modeling)과 유사합니다.

**나) UML 다이어그램 활용 (클래스 다이어그램)** 정적 모델링에 사용되는 대표적인 UML 다이어그램은 **클래스 다이어그램(Class Diagram)** 입니다. 클래스 다이어그램은 시스템의 정적인 구조 정보나 구성 요소를 나타내는 데 사용됩니다.

### 2. 동적 모델링 (Dynamic Modeling)

동적 모델링은 시스템의 행위나 객체 간의 상호 작용 등 **시간의 흐름에 따라 변화하는 측면**을 모델링하는 것을 의미합니다.

**가) 정의 및 대상** 
	동적 모델링은 정적 모델링에서 정의된 클래스의 속성과 관계를 식별하고, **객체의 상태 변화나 상호 작용**을 중심으로 모델링하는 방법을 의미합니다. 유스케이스(Use Case) 시나리오 분석을 통해 도출된 동적인 측면의 상세한 정보를 반영하여, 유스케이스 시나리오를 수행하는 과정에서 시스템 내부 객체들의 상호 작용이 어떻게 발생하는지 나타냅니다.

**나) UML 다이어그램 활용** 
	동적 모델링을 표현하는 주요 UML 다이어그램은 다음과 같습니다:
- **상호작용 다이어그램 (Interaction Diagram):** 객체 간의 상호 작용을 나타냅니다.
    - **시퀀스 다이어그램 (Sequence Diagram):** 객체 간의 상호 작용 순서를 **시간의 흐름에 따라** 명시하며, 메시지 전달 경로를 강조합니다.
    - **커뮤니케이션 다이어그램 (Communication Diagram):** 객체 간의 **협력 관계와 메시지**를 표현합니다.
- **상태 다이어그램 (Statechart Diagram):** 시스템 내부의 **상태 전이**를 나타냅니다.
- **액티비티 다이어그램 (Activity Diagram):** 시스템 내부의 **활동 흐름**을 표현합니다.


---
## 04 디자인 패턴 

### 1. 디자인 패턴의 개념 및 중요성

**가) 디자인 패턴의 정의** 
	디자인 패턴이란 소프트웨어 개발 시 발생했던 문제점을 해결하기 위한 **일반적이고 재사용 가능한 해결 방법**을 정리해 놓은 것입니다. 이는 반복적으로 사용되는 재활용성 높은 문제를 깔끔하게 관리하여, 소프트웨어 개발의 **생산성을 높이는 데 기여**합니다.

**나) VI. 객체 지향 설계와의 연관성** 
	디자인 패턴은 소프트웨어 공학의 특정 영역(Context)에서 해결할 수 있는, 객체 지향 설계의 복잡성을 해결해 줄 수 있는 해법의 모범 사례입니다. 디자인 패턴에 대한 이해는 다형성(Polymorphism)과 동적 바인딩(Run-time Binding) 등의 객체 지향 원리를 설계에 적용하기 위한 개념적 배경을 제공하며, 일반적으로 **클래스 간의 상호작용**에 초점을 맞추어 적용됩니다.

### 2. 디자인 패턴의 분류

디자인 패턴은 목적(Purpose)과 범위(Scope)에 따라 분류됩니다.

**가) 목적에 따른 분류**

1. **생성 패턴 (Creation Pattern):** 객체의 생성 과정에 관여하는 패턴입니다. (예: Abstract Factory, Builder, Factory Method, Prototype, Singleton).
    - **Singleton 패턴**은 클래스의 객체를 최대 N개 이하로 고정하고 싶을 때 사용되며, 객체의 최대 개수를 1개로 제한할 때 주로 활용됩니다.
2. **구조 패턴 (Structural Pattern):** 클래스나 객체의 **합성**에 관한 패턴입니다. (예: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy).
    - **Adapter 패턴**은 기존 클래스 인터페이스를 다른 클래스의 인터페이스로 변환하여 두 클래스를 함께 사용할 수 있도록 합니다.
    - **Facade 패턴**은 여러 클래스가 밀집된 관계를 가질 때, 그 전체적인 역할을 대리할 클래스를 정의하여 시스템에 대해 **간단한 인터페이스를 제공**하고, 객체 간의 관계를 단순화시켜 복잡하거나 회귀적인 의존 관계를 제거합니다.
3. **행위 패턴 (Behavioral Pattern):** 클래스나 객체의 **상호작용 및 책임 분배**를 정의하는 패턴입니다. (예: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor).
    - **Observer 패턴**은 하나의 객체 상태가 변할 때 관련된 객체들이 자동으로 통지받고 업데이트되도록 (one-to-many dependency) 설계됩니다.

**나) 범위에 따른 분류**

1. **클래스 패턴 (Class Pattern):** 클래스와 서브 클래스 간의 관계를 다루는 패턴으로, **상속**에 의해 컴파일 타임에 정적으로 결정됩니다.
2. **객체 패턴 (Object Pattern):** 객체 간의 관계를 다루는 패턴으로, 런타임에 동적으로 변경될 수 있는 **동적인 성격**을 가집니다.

### 3. 디자인 패턴의 효과

디자인 패턴은 VI. 객체 지향 설계의 목표인 **재사용성, 유지보수성, 확장성**을 달성하는 데 직접적으로 기여합니다.

- **코드 재사용성:** 디자인 패턴은 반복적으로 사용되는 재활용성 높은 문제 해결 방식을 정리한 것이므로, 이를 사용하여 개발 생산성을 높이고 시스템 품질을 개선하는 데 효과적입니다.
- **유연성과 확장성 확보:** 디자인 패턴을 통해 클래스 간의 결합도를 낮추고 책임 분배를 명확히 함으로써, 새로운 기능 추가나 변경 사항에 유연하게 대응할 수 있는 시스템 구조를 구축합니다.
- **설계의 표준화:** 디자인 패턴은 특정 문제에 대한 전문가들의 검증된 해결책이므로, 설계 경험이 부족하더라도 복잡한 문제를 안정적으로 해결할 수 있는 표준화된 설계 방법을 제공합니다.
--- 

### Quiz 

SOLID 원칙 중, 하나의 클래스는 하나의 책임만 가져야 한다는 원칙은 무엇인가요? - 단일 책임 원칙 

SOLID 원칙 중, 소프트웨어 개체는 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 원칙은 무엇인가요? - 개방 폐쇄 원칙 

SOLID 원칙 중, 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 정확성이 깨지지 않아야 한다는 원칙은 무엇인가요? - 리스코프 치환 원칙 

SOLID 원칙 중, 클라이언트는 자신이 사용하지 않는 인터페이스에 의존 관계를 맺으면 안 된다는 원칙은 무엇인가요? - 인터페이스 분리 원칙 

SOLID 원칙 중, 상위 모듈은 하위 모듈에 의존해서는 안 되며 둘 다 추상화에 의존해야 한다는 원칙은 무엇인가요? - 의존성 역전 원칙

객체 지향의 핵심 원리 중, 데이터(속성)와 그 데이터를 처리하는 함수(메서드)를 하나로 묶고, 내부 구현을 외부에서 알 수 없게 하는 것은 무엇인가요? - 캡슐화 

객체 지향의 핵심 원리 중, 상위 클래스의 속성과 메서드를 하위 클래스가 물려받아 재사용하고 확장할 수 있게 하는 것은 무엇인가요? - 상속

객체 지향의 핵심 원리 중, 하나의 메시지나 메서드 호출에 대해 객체에 따라 서로 다른 방식으로 동작할 수 있는 능력은 무엇인가요? - 다형성

시스템을 구성하는 클래스, 속성, 관계 등 정적인 측면을 모델링하는 것을  _ 모델링이라고 합니다. - 정적(Static) 

시간의 흐름에 따른 객체 간의 상호작용이나 상태 변화 등 동적인 측면을 모델링하는 것을 _ 모델링이라고 합니다. - 동적 (Dynamic)

디자인 패턴의 세 가지 분류는 무엇인가요? - 생성 패턴, 구조 패턴, 행위 패턴 

객체의 생성과 관련된 문제를 다루며, 객체 생성 과정을 캡슐화하여 코드의 유연성을 높이는 디자인 패턴의 분류는 무엇인가요? - 생성 패턴 

클래스나 객체를 조합하여 더 큰 구조를 만들 수 있게 하는 패턴으로, 구조가 복잡해지는 것을 방지하는 디자인 패턴의 분류는 무엇인가요? - 구조 패턴 

객체 간의 상호작용 방식과 책임을 분산하는 방법을 정의하는 디자인 패턴의 분류는 무엇인가요? - 행위 패턴 

특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하고, 어디서든 그 인스턴스에 접근할 수 있도록 하는 생성 패턴은 무엇인가요? - 싱글턴 패턴 

여러 개의 서브시스템을 감싸는 단일 인터페이스를 제공하여 복잡한 시스템을 간편하게 사용할 수 있도록 하는 구조 패턴은 무엇인가요? - 퍼사드 패턴 

한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 자동으로 알려주고 업데이트하는 행위 패턴은 무엇인가요? - 옵저버 패턴 

알고리즘군을 정의하고 각각을 캡슐화하여 상호 교환이 가능하도록 만드는 행위 패턴은 무엇인가요? - 전략 패턴 

알고리즘의 골격은 상위 클래스에서 정의하고 일부 단계를 하위 클래스에서 구현하도록 하는 행위 패턴은 무엇인가요? - 템플릿 메서드 패턴 

